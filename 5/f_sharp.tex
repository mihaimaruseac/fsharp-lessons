\documentclass{beamer}

\usepackage{hyperref}
\mode<presentation>

\title{F\#.5 : Imperative and Object Oriented F\#}
\author{Mihai Maruseac, ROSEdu\\mihai@rosedu.org}

\setbeamertemplate{frametitle continuation}[from second]
\setbeamertemplate{footline}[frame number]

\begin{document}

\maketitle

\begin{frame}
  \tableofcontents
\end{frame}

\begin{frame}{Last time...}
  \begin{itemize}[<+->]
    \item Active Patterns
    \item Units of Measure
    \item Functors
    \item Applicative
    \item Monads / Computation Expressions
    \item Typeclassopedia
  \end{itemize}
\end{frame}

\section{Imperative Programming}
\frame{\tableofcontents[currentsection]}

\begin{frame}[fragile]{Mutable Variables}
  \begin{itemize}[<+->]
    \item Classical functional programming: values
    \item Immutable
    \item Allows "cool" effects: laziness, $\ldots$
    \item F\# has mutable data: \texttt{mutable}
  \end{itemize}
  \pause
  \begin{verbatim}
  > let mutable x = 5;;
  > x <- 10;;
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Mutable Record Fields}
  \begin{verbatim}
type transactionItem =
    { ID : int;
        mutable IsProcessed : bool;
        mutable ProcessedText : string; }

let processItems (items : transactionItem list) =
    items |> List.iter(fun item ->
        item.IsProcessed <- true
        item.ProcessedText <- sprintf "Processed %s"
                 (DateTime.Now.ToString("hh:mm:ss"))
        )
  \end{verbatim}
\end{frame}

\begin{frame}{Usefulness}
  \begin{itemize}[<+->]
    \item caching
    \item memoization
    \item no need for multiple copies
    \item arrays
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{F\# Arrays}
  \begin{verbatim}
  > [| 1; 2; 3; 4; 5 |];;
  > [| 1 .. 10 |];;
  > [| 1 .. 3 .. 10 |];;
  > [| for a in 1 .. 5 do
      yield (a, a*a, a*a*a) |];;
  \end{verbatim}
\end{frame}

\begin{frame}{Array Init}
  \begin{itemize}[<+->]
    \item \texttt{System.Array}
    \item \texttt{zeroCreate : int -> 'T []}
    \item \texttt{create : int -> 'T -> 'T []}
    \item \texttt{init : int -> (int -> 'T) -> 'T []}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Indexing}
  \begin{verbatim}
  > for i = 0 to names.Length - 1 do
      printfn "%s" (names.[i]);;
  > names.[1..3];;
  > names.[2..];;
  > names.[..3];;
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Multidimensional Arrays : Rectangles}
\small
  \begin{verbatim}
> let grid = Array2D.init<string> 3 3
      (fun row col -> sprintf "%i, %i" row col);;
> grid;;
val it : string [,]
= [|[|"0, 0"; "0, 1"; "0, 2"|];
    [|"1, 0"; "1, 1"; "1, 2"|];
    [|"2, 0"; "2, 1"; "2, 2"|]|]
> grid.[0, 1];;
val it : string = "0, 1"
> grid.[1, 2];;
val it : string = "1, 2"
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Multidimensional Arrays : Jagged}
  \begin{verbatim}
> [| for a in 1 .. 5 do yield [| 1 .. a |] |];;
val it : int array array
= [|[|1|];
    [|1; 2|];
    [|1; 2; 3|];
    [|1; 2; 3; 4|];
    [|1; 2; 3; 4; 5|]|]

> jagged.[2].[2];;
val it : int = 3

> jagged.[4].[0];;
val it : int = 1
  \end{verbatim}
\end{frame}

\begin{frame}{Multidimensional Arrays}
  \begin{itemize}[<+->]
    \item 2 different types
    \item rectangular - flat
    \item jagged - array of pointers
    \item non-interchangeable
    \item rectangular more efficient than jagged
    \item more than 2 dimensions?
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{Array} Module}
  \begin{itemize}
    \item \texttt{val append : 'T[] -> 'T[] -> 'T[]}
    \item \texttt{fill : 'T[] input -> int -> int -> 'T -> unit}
    \item \texttt{rev : 'T[] -> 'T[]}
    \item \texttt{sub : 'T[] -> int -> int -> 'T[]}
    \item \texttt{length : 'T[] -> int}
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{Array} Module : Sorting}
  \begin{itemize}
    \item \texttt{sort : 'T[] -> 'T[]}
    \item \texttt{sortInPlace : 'T[] -> unit}
    \item \texttt{sortBy : ('T -> 'T -> int) -> 'T[] -> 'T[]}
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{Array} Module}
  \begin{itemize}
    \item \texttt{iter : ('T -> unit) -> 'T[] input -> unit}
    \item \texttt{map : ('T -> 'U) -> 'T[] -> 'U[]}
    \item \texttt{filter : ('T -> bool) -> 'T[] -> 'T[]}
    \item \texttt{choose : ('T -> 'U option) -> 'T[] -> 'U[]}
    \item \texttt{fold : ('State -> 'T -> 'State) -> 'State -> 'T[] input -> 'State}
    \item \texttt{foldBack : ('T -> 'State -> 'State) -> 'T[] input -> 'State -> 'State}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Limitations of Mutable Variables}
  \begin{verbatim}
> let testMutable() =
    let mutable msg = "hello"
    printfn "%s" msg

    let setMsg() =
        msg <- "world"

    setMsg()
    printfn "%s" msg;;
  \end{verbatim}
  \pause
  \begin{itemize}
    \item inaccessible outside function scope
    \item not in closures
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Ref Cells}
  \begin{verbatim}
  type 'a ref = { mutable contents : 'a }
  \end{verbatim}
  \pause
  \begin{verbatim}
  let ref v = { contents = v }
  let (!) r = r.contents
  let (:=) r v = r.contents <- v
  \end{verbatim}
  \pause
  \begin{verbatim}
  > let x = ref "hello";;
  val x : string ref
  > x;;
  val it : string ref = {contents = "hello";}
  > !x;;
  val it : string = "hello"
  > x := "world";;
  val it : unit = ()
  > !x;;
  val it : string = "world"
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Ref Sharing}
  \begin{verbatim}
let withSideEffects x =
    x := "assigned from withSideEffects function"
 
let refTest() =
    let msg = ref "hello"
    printfn "%s" !msg
 
    let setMsg() =
        msg := "world"
 
    setMsg()
    printfn "%s" !msg
 
    withSideEffects msg
    printfn "%s" !msg
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Aliasing}
  \begin{itemize}[<+->]
    \item ref cell $\sim$ C pointer
    \item multiple ref cells pointing to same memory location
  \end{itemize}
  \pause
  \begin{verbatim}
> let cell1 = ref 7;;
> let cell2 = cell1;;
> let cell3 = cell2;;

> !cell1;;
val it : int = 7

> !cell2;;
val it : int = 7

> cell1 := 10;;
val it : unit = ()

> !cell3;;
val it : int = 10
  \end{verbatim}
\end{frame}

\begin{frame}{Cell Refs Pitfalls}
  \begin{itemize}[<+->]
    \item aliasing problems
    \item no more easy parallelization
    \item no more proof correctness
    \item no more declarative programming
    \item ref cells should be treated like \textit{fire}
    \item use cautiously
    \item use only when absolutely necessary
    \pause
    \item useful when translating C programs
    \item elegant and more maintainable functional solution
    \item profile
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{State Encapsulation}
  \begin{itemize}[<+->]
    \item threading state between functions - \textbf{discouraged}
    \item hide state in private functions
  \end{itemize}
  \pause
  \begin{verbatim}
> let incr =
    let counter = ref 0
    fun () ->
        counter := !counter + 1
        !counter;;

> incr();;
val it : int = 1
> incr();;
val it : int = 2
> incr();;
val it : int = 3
  \end{verbatim}
\end{frame}

\section{Object Oriented Programming}
\frame{\tableofcontents[currentsection]}

\begin{frame}{Classes}
\end{frame}

\begin{frame}{Inheritance}
\end{frame}

\begin{frame}{Abstract Classes}
\end{frame}

\begin{frame}{Interfaces}
\end{frame}

\begin{frame}{Object Expressions}
\end{frame}

\begin{frame}{Using OO Features in F\#}
\end{frame}

\section{Finishing slides}
\frame{\tableofcontents[currentsection]}

\begin{frame}{Seamless .NET Integration}
\end{frame}

\begin{frame}{C\# $\sim$ F\#}
\end{frame}

\begin{frame}{Recap}
  \begin{itemize}[<+->]
    \item mutable variables
    \item Arrays
    \item ref cells
    \item OO features
    \item .NET integration
  \end{itemize}
\end{frame}

\end{document}
